
#' This is an edited version of lognet from {glmnet}
#' that allows fitting a regularized glm in case of imbalanced data with one class <= 1


# Needs ix and jx for possible subsetting.
lognet=function(x,is.sparse,ix,jx,y,weights,offset,alpha,nobs,nvars,jd,vp,cl,ne,nx,nlam,flmin,ulam,thresh,isd,intr,vnames,maxit,kopt,family,pb){
  nc=dim(y)
  maxit=as.integer(maxit)
  if(is.null(nc)){
    ## Need to construct a y matrix, and include the weights
    y=as.factor(y)
    ntab=table(y)
    minclass=min(ntab)
    if(minclass<=0)warning("one class is not present in training data at all")
    if(minclass<8)warning("one multinomial or binomial class has fewer than 8  observations; dangerous ground")
    classnames=names(ntab)
    nc=as.integer(length(ntab))
    y=diag(nc)[as.numeric(y),]
  }
  else{
    noo=nc[1]
    if(noo!=nobs)stop("x and y have different number of rows in call to glmnet",call.=FALSE)
    nc=as.integer(nc[2])
    classnames=colnames(y)
  }
  #Check for size limitations
  maxvars=.Machine$integer.max/(nlam*nc)
  if(nx>maxvars)stop(paste("Integer overflow; num_classes*num_lambda*pmax should not exceed .Machine$integer.max. Reduce pmax to be below", trunc(maxvars)))
  
  if(!missing(weights)) y=y*weights
  ### check if any rows of y sum to zero, and if so deal with them
  weights=drop(y%*%rep(1,nc))
  o=weights>0
  if(!all(o)){ #subset the data
    y=y[o,]
    if(is.sparse){ # we have to subset this beast with care
      x=sparseMatrix(i=jx,p=ix-1,x=x@x,dims=c(nobs,nvars))[o,,drop=FALSE]
    }
    else x=x[o,,drop=FALSE]
    nobs=sum(o)
  }else o=NULL
  
  
  if(family=="binomial"){
    if(nc>2)stop("More than two classes; use multinomial family instead in call to glmnet",call.=FALSE)
    nc=as.integer(1) # for calling lognet
    y=y[,c(2,1)]#C++ lognet models the first column; we prefer the second (for 0/1 data)
  }
  
  
  storage.mode(y)="double"
  if(is.null(offset)){
    offset=y*0 #keeps the shape of y
    is.offset=FALSE
  }
  else{
    offset=as.matrix(offset)
    if(!is.null(o))offset=offset[o,,drop=FALSE]# we might have zero weights
    do=dim(offset)
    if(do[[1]]!=nobs)stop("offset should have the same number of values as observations in binomial/multinomial call to glmnet",call.=FALSE)
    if((do[[2]]==1)&(nc==1))offset=cbind(offset,-offset)
    if((family=="multinomial")&(do[[2]]!=nc))stop("offset should have same shape as y in multinomial call to glmnet",call.=FALSE)
    storage.mode(offset)="double"
    is.offset=TRUE
  }
  
  # C++ expects offset to have nc number of columns, as documented in Fortran.
  # We do a final modification of offset to take only the first column, since we favor this when fitting.
  if (nc == 1) offset=as.matrix(offset[,1], ncol=1)
  
  fit=if(is.sparse) splognet_exp(
    parm=alpha,x,y,offset,jd,vp,cl,ne=ne,nx,nlam,flmin,ulam,thresh,isd,intr,maxit,kopt,pb,
    lmu=integer(1),
    a0=matrix(0.0, nc, nlam),
    ca=double(nx*nlam*nc),
    ia=integer(nx),
    nin=integer(nlam),
    nulldev=double(1),
    dev=double(nlam),
    alm=double(nlam),
    nlp=integer(1),
    jerr=integer(1)
  )
  else lognet_exp(
    parm=alpha,x,y,offset,jd,vp,cl,ne,nx,nlam,flmin,ulam,thresh,isd,intr,maxit,kopt,pb,
    lmu=integer(1),
    a0=matrix(0.0, nc, nlam),
    ca=double(nx*nlam*nc),
    ia=integer(nx),
    nin=integer(nlam),
    nulldev=double(1),
    dev=double(nlam),
    alm=double(nlam),
    nlp=integer(1),
    jerr=integer(1)
  )
  if(fit$jerr!=0){
    errmsg=jerr(fit$jerr,maxit,pmax=nx,family)
    if(errmsg$fatal)stop(errmsg$msg,call.=FALSE)
    else warning(errmsg$msg,call.=FALSE)
  }
  if(family=="binomial"){
    outlist=getcoef(fit,nvars,nx,vnames)
    #   outlist$a0=-outlist$a0#sign flips make 2 target class
    #   outlist$beta=-outlist$beta#sign flips make 2 target class
  }
  else  outlist=getcoef.multinomial(fit,nvars,nx,vnames,nc,classnames)
  dev=fit$dev[seq(fit$lmu)]
  outlist=c(outlist,list(dev.ratio=dev,nulldev=fit$nulldev,npasses=fit$nlp,jerr=fit$jerr,offset=is.offset,classnames=classnames))
  if(family=="multinomial"){
    if(kopt==2)grouped=TRUE else grouped =FALSE
    outlist$grouped=grouped
  }
  class(outlist)=switch(family,
                        "binomial"="lognet",
                        "multinomial"="multnet"
  )
  outlist
}


# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

elnet_exp <- function(ka, parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr) {
  .Call('_glmnet_elnet_exp', PACKAGE = 'glmnet', ka, parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr)
}

spelnet_exp <- function(ka, parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr) {
  .Call('_glmnet_spelnet_exp', PACKAGE = 'glmnet', ka, parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr)
}

lognet_exp <- function(parm, x, y, g, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, kopt, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr) {
  .Call('_glmnet_lognet_exp', PACKAGE = 'glmnet', parm, x, y, g, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, kopt, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr)
}

splognet_exp <- function(parm, x, y, g, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, kopt, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr) {
  .Call('_glmnet_splognet_exp', PACKAGE = 'glmnet', parm, x, y, g, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, kopt, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr)
}

fishnet_exp <- function(parm, x, y, g, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr) {
  .Call('_glmnet_fishnet_exp', PACKAGE = 'glmnet', parm, x, y, g, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr)
}

spfishnet_exp <- function(parm, x, y, g, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr) {
  .Call('_glmnet_spfishnet_exp', PACKAGE = 'glmnet', parm, x, y, g, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, intr, maxit, pb, lmu, a0, ca, ia, nin, nulldev, dev, alm, nlp, jerr)
}

multelnet_exp <- function(parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, jsd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr) {
  .Call('_glmnet_multelnet_exp', PACKAGE = 'glmnet', parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, jsd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr)
}

multspelnet_exp <- function(parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, jsd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr) {
  .Call('_glmnet_multspelnet_exp', PACKAGE = 'glmnet', parm, x, y, w, jd, vp, cl, ne, nx, nlam, flmin, ulam, thr, isd, jsd, intr, maxit, pb, lmu, a0, ca, ia, nin, rsq, alm, nlp, jerr)
}

get_int_parms <- function(fdev, eps, big, mnlam, devmax, pmin, exmx, itrace) {
  .Call('_glmnet_get_int_parms', PACKAGE = 'glmnet', fdev, eps, big, mnlam, devmax, pmin, exmx, itrace)
}

get_int_parms2 <- function(epsnr, mxitnr) {
  .Call('_glmnet_get_int_parms2', PACKAGE = 'glmnet', epsnr, mxitnr)
}

chg_fract_dev <- function(arg) {
  invisible(.Call('_glmnet_chg_fract_dev', PACKAGE = 'glmnet', arg))
}

chg_dev_max <- function(arg) {
  invisible(.Call('_glmnet_chg_dev_max', PACKAGE = 'glmnet', arg))
}

chg_min_flmin <- function(arg) {
  invisible(.Call('_glmnet_chg_min_flmin', PACKAGE = 'glmnet', arg))
}

chg_big <- function(arg) {
  invisible(.Call('_glmnet_chg_big', PACKAGE = 'glmnet', arg))
}

chg_min_lambdas <- function(irg) {
  invisible(.Call('_glmnet_chg_min_lambdas', PACKAGE = 'glmnet', irg))
}

chg_min_null_prob <- function(arg) {
  invisible(.Call('_glmnet_chg_min_null_prob', PACKAGE = 'glmnet', arg))
}

chg_max_exp <- function(arg) {
  invisible(.Call('_glmnet_chg_max_exp', PACKAGE = 'glmnet', arg))
}

chg_itrace <- function(irg) {
  invisible(.Call('_glmnet_chg_itrace', PACKAGE = 'glmnet', irg))
}

chg_bnorm <- function(arg, irg) {
  invisible(.Call('_glmnet_chg_bnorm', PACKAGE = 'glmnet', arg, irg))
}

get_bnorm <- function(prec, mxit) {
  .Call('_glmnet_get_bnorm', PACKAGE = 'glmnet', prec, mxit)
}

chg_epsnr <- function(arg) {
  invisible(.Call('_glmnet_chg_epsnr', PACKAGE = 'glmnet', arg))
}

chg_mxitnr <- function(irg) {
  invisible(.Call('_glmnet_chg_mxitnr', PACKAGE = 'glmnet', irg))
}

wls_exp <- function(alm0, almc, alpha, m, no, ni, x, r, xv, v, intr, ju, vp, cl, nx, thr, maxit, a, aint, g, ia, iy, iz, mm, nino, rsqc, nlp, jerr) {
  .Call('_glmnet_wls_exp', PACKAGE = 'glmnet', alm0, almc, alpha, m, no, ni, x, r, xv, v, intr, ju, vp, cl, nx, thr, maxit, a, aint, g, ia, iy, iz, mm, nino, rsqc, nlp, jerr)
}

spwls_exp <- function(alm0, almc, alpha, m, no, ni, x, xm, xs, r, xv, v, intr, ju, vp, cl, nx, thr, maxit, a, aint, g, ia, iy, iz, mm, nino, rsqc, nlp, jerr) {
  .Call('_glmnet_spwls_exp', PACKAGE = 'glmnet', alm0, almc, alpha, m, no, ni, x, xm, xs, r, xv, v, intr, ju, vp, cl, nx, thr, maxit, a, aint, g, ia, iy, iz, mm, nino, rsqc, nlp, jerr)
}

getcoef=function(fit,nvars,nx,vnames){
  lmu=fit$lmu
  if(lmu<1){
    ## changed this to a warning message, and return an empty model
    warning("an empty model has been returned; probably a convergence issue")
    coefob=list(a0=fit$a0,beta=zeromat(nvars,as.integer(1),vnames,"s0"),df=0,dim=c(nvars,1),lambda=Inf)
    return(coefob)
  }
  nin=fit$nin[seq(lmu)]
  ninmax=max(nin)
  lam=fit$alm[seq(lmu)]
  
  stepnames=paste("s",seq(lmu)-1,sep="")
  dd=c(nvars,lmu)
  if(ninmax>0){
    ca=matrix(fit$ca[seq(nx*lmu)],nx,lmu)[seq(ninmax),,drop=FALSE]
    df=apply(abs(ca)>0,2,sum)
    ja=fit$ia[seq(ninmax)]
    ####confusing but too hard to change
    ###glmnet builds a list of ever active variables which is nondecreasing
    ###Since ca was initialized to zero, no harm is done in passing a square matrix
    ###to new(); then when we do a drop0 it makes it really sparse
    oja=order(ja)
    ja=rep(ja[oja],lmu)
    ia=cumsum(c(1,rep(ninmax,lmu)))
    beta=drop0(new("dgCMatrix",Dim=dd,Dimnames=list(vnames,stepnames),x=as.vector(ca[oja,]),p=as.integer(ia-1),i=as.integer(ja-1)))
  }else {
    beta = zeromat(nvars,lmu,vnames,stepnames)
    df=rep(0,lmu)
  }
  a0=fit$a0
  if(!is.null(a0)){#for Cox model
    a0=a0[seq(lmu)]
    names(a0)=stepnames
  }
  list(a0=a0,beta=beta,df=df,dim=dd,lambda=lam)
}

jerr=function(n,maxit,pmax,family){
  if(n==0) list(n=0,fatal=FALSE,msg="")
  else {
    errlist=switch(family,
                   "gaussian"=jerr.elnet(n,maxit,pmax),
                   "binomial"=jerr.lognet(n,maxit,pmax),
                   "multinomial"=jerr.lognet(n,maxit,pmax),
                   "poisson"=jerr.fishnet(n,maxit,pmax),
                   "cox"=jerr.coxnet(n,maxit,pmax),
                   "mrelnet"=jerr.mrelnet(n,maxit,pmax)
    )
    names(errlist)=c("n","fatal","msg")
    errlist$msg=paste("from glmnet Fortran code (error code ",n, "); ",errlist$msg,sep="")
    errlist
  }
}


jerr.lognet=function(n,maxit,pmax){
  outlist=jerr.elnet(n,maxit,pmax)
  if(n<  -20000)outlist$msg=paste("Max(p(1-p),1.0e-6 at ",-n-20000,"th value of lambda; solutions for larger values of lambda returned")
  if(outlist$msg!="Unknown error")return(outlist)
  if((8000<n) & (n<9000))msg=paste("Null probability for class",n-8000, "< 1.0e-5")
  else if((9000<n) & (n<10000))msg=paste("Null probability for class",n-9000, "> 1.0 - 1.0e-5")
  else msg="Unknown error"
  list(n=n,fatal=TRUE,msg=msg)
}

jerr.elnet=function(n,maxit,pmax){
  if(n>0){#fatal error
    if(n<7777)msg="Memory allocation error; contact package maintainer"
    else if(n==7777)msg="All used predictors have zero variance"
    else if(n==10000)msg="All penalty factors are <= 0"
    else msg="Unknown error"
    list(n=n,fatal=TRUE,msg=msg)
  }
  else if(n<0){# non-fatal error
    if(n>-10000)msg=paste("Convergence for ",-n,"th lambda value not reached after maxit=",maxit," iterations; solutions for larger lambdas returned",sep="")
    if(n < -10000)msg=paste("Number of nonzero coefficients along the path exceeds pmax=",pmax, " at ",-n-10000,"th lambda value; solutions for larger lambdas returned",sep="")
    list(n=n,fatal=FALSE,msg=msg)
  }
  
}



# assure that the function will be able to call other hidden functions from the package. 
assignInNamespace("lognet", lognet, ns = "glmnet")
environment(lognet) <- asNamespace('glmnet')


